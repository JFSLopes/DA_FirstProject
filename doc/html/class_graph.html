<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stores information in a graph structure.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b53f39cb46a078ec23019689f0b078b" id="r_a1b53f39cb46a078ec23019689f0b078b"><td class="memItemLeft" align="right" valign="top"><a id="a1b53f39cb46a078ec23019689f0b078b" name="a1b53f39cb46a078ec23019689f0b078b"></a>
const std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexSet</b> () const</td></tr>
<tr class="separator:a1b53f39cb46a078ec23019689f0b078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b303fc43e1282bf965758aa6777269" id="r_a81b303fc43e1282bf965758aa6777269"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a81b303fc43e1282bf965758aa6777269">incomeEdgesFull</a> (std::vector&lt; std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;allPaths) const</td></tr>
<tr class="memdesc:a81b303fc43e1282bf965758aa6777269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the income edges of the subgraph are full or close to.  <br /></td></tr>
<tr class="separator:a81b303fc43e1282bf965758aa6777269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e031377ef9900b346f1ec9f7138f2d" id="r_a60e031377ef9900b346f1ec9f7138f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a60e031377ef9900b346f1ec9f7138f2d">findAllPaths</a> (<a class="el" href="class_vertex.html">Vertex</a> *s, std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;path, std::vector&lt; std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;paths) const</td></tr>
<tr class="memdesc:a60e031377ef9900b346f1ec9f7138f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all paths from a vertex to any delivery site.  <br /></td></tr>
<tr class="separator:a60e031377ef9900b346f1ec9f7138f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd115f2a5335b5a426c491416d9f59fd" id="r_afd115f2a5335b5a426c491416d9f59fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_city.html">City</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afd115f2a5335b5a426c491416d9f59fd">getCity</a> (cityEnum type, std::string &amp;str, uint32_t id) const</td></tr>
<tr class="memdesc:afd115f2a5335b5a426c491416d9f59fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a city in the graph.  <br /></td></tr>
<tr class="separator:afd115f2a5335b5a426c491416d9f59fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1339be85fed6670fa20570ade04b8d" id="r_a3b1339be85fed6670fa20570ade04b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_station.html">Station</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3b1339be85fed6670fa20570ade04b8d">getStation</a> (stationEnum type, std::string &amp;str, uint32_t id) const</td></tr>
<tr class="memdesc:a3b1339be85fed6670fa20570ade04b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a city in the graph.  <br /></td></tr>
<tr class="separator:a3b1339be85fed6670fa20570ade04b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92fa5002413372c5fb841cf6c800f8" id="r_acb92fa5002413372c5fb841cf6c800f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_reservoir.html">Reservoir</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acb92fa5002413372c5fb841cf6c800f8">getReservoir</a> (reservoirEnum type, std::string &amp;str, uint32_t id) const</td></tr>
<tr class="memdesc:acb92fa5002413372c5fb841cf6c800f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a reservoir in the graph.  <br /></td></tr>
<tr class="separator:acb92fa5002413372c5fb841cf6c800f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01046a11706fbfcea0c467bdaeadb0d5" id="r_a01046a11706fbfcea0c467bdaeadb0d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a01046a11706fbfcea0c467bdaeadb0d5">findVertex</a> (std::string &amp;code) const</td></tr>
<tr class="memdesc:a01046a11706fbfcea0c467bdaeadb0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to find a vertex on the graph.  <br /></td></tr>
<tr class="separator:a01046a11706fbfcea0c467bdaeadb0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb6dc6411a88720c3448d6b1d715f4" id="r_a03eb6dc6411a88720c3448d6b1d715f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a03eb6dc6411a88720c3448d6b1d715f4">addVertex</a> (<a class="el" href="class_vertex.html">Vertex</a> *node)</td></tr>
<tr class="memdesc:a03eb6dc6411a88720c3448d6b1d715f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <br /></td></tr>
<tr class="separator:a03eb6dc6411a88720c3448d6b1d715f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bf892a442aa0f2922c36d861951cb6" id="r_aa9bf892a442aa0f2922c36d861951cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9bf892a442aa0f2922c36d861951cb6">removeVertex</a> (<a class="el" href="class_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:aa9bf892a442aa0f2922c36d861951cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the vertex all all the connection it belonged to.  <br /></td></tr>
<tr class="separator:aa9bf892a442aa0f2922c36d861951cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46a70e152899f5cd6d849aae5aea76d" id="r_ad46a70e152899f5cd6d849aae5aea76d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad46a70e152899f5cd6d849aae5aea76d">findAugPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink, <a class="el" href="class_vertex.html">Vertex</a> *removed=nullptr)</td></tr>
<tr class="memdesc:ad46a70e152899f5cd6d849aae5aea76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an augmenting path in the residual graph.  <br /></td></tr>
<tr class="separator:ad46a70e152899f5cd6d849aae5aea76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398749631275c96ec19e138b8a41a0fe" id="r_a398749631275c96ec19e138b8a41a0fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a398749631275c96ec19e138b8a41a0fe">findAugPathSubGraph</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;subGraph)</td></tr>
<tr class="memdesc:a398749631275c96ec19e138b8a41a0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an augmenting path in the residual subgraph from the source to the sink vertex, using BFS (breadth-first search)  <br /></td></tr>
<tr class="separator:a398749631275c96ec19e138b8a41a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38f1c9d15d4c20de90a78700da74a35" id="r_ac38f1c9d15d4c20de90a78700da74a35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac38f1c9d15d4c20de90a78700da74a35">minResAugPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink)</td></tr>
<tr class="memdesc:ac38f1c9d15d4c20de90a78700da74a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find a minimal augmenting path in the residual graph.  <br /></td></tr>
<tr class="separator:ac38f1c9d15d4c20de90a78700da74a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30911cf23d21b266464621a233b89370" id="r_a30911cf23d21b266464621a233b89370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a30911cf23d21b266464621a233b89370">augmentFlowPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink, double f)</td></tr>
<tr class="memdesc:a30911cf23d21b266464621a233b89370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the flow along the augmenting path found in the residual network from the source vertex to destination vertex The flow is increased by the amount f given in the arguments.  <br /></td></tr>
<tr class="separator:a30911cf23d21b266464621a233b89370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86360a1cb3c17ab52d915f662c2d802" id="r_af86360a1cb3c17ab52d915f662c2d802"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af86360a1cb3c17ab52d915f662c2d802">edmondsKarp</a> ()</td></tr>
<tr class="memdesc:af86360a1cb3c17ab52d915f662c2d802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Edmonds-Karp algorithm to find the maximum flow in a flow network This is done by finding augmenting paths in the residual network and augmenting the flow along the paths.  <br /></td></tr>
<tr class="separator:af86360a1cb3c17ab52d915f662c2d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb5b49c229860f491d00e3dd4a2f677" id="r_a2bb5b49c229860f491d00e3dd4a2f677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2bb5b49c229860f491d00e3dd4a2f677">edmondsKarpRemovePipeline</a> (<a class="el" href="class_edge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:a2bb5b49c229860f491d00e3dd4a2f677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pipeline from the flow network and then implements the Edmonds-Karp algorithm to find the maximum flow without the specified pipeline.  <br /></td></tr>
<tr class="separator:a2bb5b49c229860f491d00e3dd4a2f677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276893daa6d639661b2474b36808f9ce" id="r_a276893daa6d639661b2474b36808f9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a276893daa6d639661b2474b36808f9ce">edmondsKarpRemoveReservoir</a> (<a class="el" href="class_vertex.html">Vertex</a> *reservoir)</td></tr>
<tr class="memdesc:a276893daa6d639661b2474b36808f9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a reservoir from the flow network and then implements the Edmonds-Karp algorithm to find the maximum flow without the specified reservoir After removing the reservoir, checks the effects on the water needs of the cities and prints the deficits caused by the removal.  <br /></td></tr>
<tr class="separator:a276893daa6d639661b2474b36808f9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340cad7c7759b5a052134e80453da6c1" id="r_a340cad7c7759b5a052134e80453da6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a340cad7c7759b5a052134e80453da6c1">edmondsKarpRemovePumpingStation</a> (<a class="el" href="class_vertex.html">Vertex</a> *pumpingStation)</td></tr>
<tr class="memdesc:a340cad7c7759b5a052134e80453da6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pumping station from the flow network and then implements the Edmonds-Karp algorithm to find the maximum flow after the removal.  <br /></td></tr>
<tr class="separator:a340cad7c7759b5a052134e80453da6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1721869d8c887ef0cf5342b3459a98a" id="r_ae1721869d8c887ef0cf5342b3459a98a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmetrics.html">metrics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae1721869d8c887ef0cf5342b3459a98a">calculateMetrics</a> () const</td></tr>
<tr class="memdesc:ae1721869d8c887ef0cf5342b3459a98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the basic metrics of the network such as the average, variance and maximum difference.  <br /></td></tr>
<tr class="separator:ae1721869d8c887ef0cf5342b3459a98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f56175964d25bc53cfb65c80f82644" id="r_a75f56175964d25bc53cfb65c80f82644"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::pair&lt; std::string, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a75f56175964d25bc53cfb65c80f82644">checkWaterNeeds</a> ()</td></tr>
<tr class="memdesc:a75f56175964d25bc53cfb65c80f82644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify if all the water reservoirs supply enough water to all its delivery sites.  <br /></td></tr>
<tr class="separator:a75f56175964d25bc53cfb65c80f82644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dff29065dccbd8e35ca6c8d98b4843c" id="r_a0dff29065dccbd8e35ca6c8d98b4843c"><td class="memItemLeft" align="right" valign="top"><a id="a0dff29065dccbd8e35ca6c8d98b4843c" name="a0dff29065dccbd8e35ca6c8d98b4843c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>balanceLoad</b> ()</td></tr>
<tr class="memdesc:a0dff29065dccbd8e35ca6c8d98b4843c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions balances the load in the graph redistributing flow from edges that are more close to being full to alternative paths It finds alternative paths with the same source and destination vertex and redistributes the flow accordingly. <br /></td></tr>
<tr class="separator:a0dff29065dccbd8e35ca6c8d98b4843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445ee06622688209e83d60fc96dffb58" id="r_a445ee06622688209e83d60fc96dffb58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a445ee06622688209e83d60fc96dffb58">removeReservoir</a> (<a class="el" href="class_vertex.html">Vertex</a> *reservoir)</td></tr>
<tr class="memdesc:a445ee06622688209e83d60fc96dffb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to see how the delivery sites are affected when a reservoir is removed.  <br /></td></tr>
<tr class="separator:a445ee06622688209e83d60fc96dffb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7c1fa61faa4e740c2375799a78c84b" id="r_a9c7c1fa61faa4e740c2375799a78c84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9c7c1fa61faa4e740c2375799a78c84b">removePumpingStation</a> (<a class="el" href="class_vertex.html">Vertex</a> *pumpingStation)</td></tr>
<tr class="memdesc:a9c7c1fa61faa4e740c2375799a78c84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to see if by temporarily removing a pumping station affects the delivery capacity to all the cities.  <br /></td></tr>
<tr class="separator:a9c7c1fa61faa4e740c2375799a78c84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores information in a graph structure. </p>
<p>This class allows to store all types of nodes, in this case Pumping <a class="el" href="class_station.html" title="Allows to represent a station.">Station</a>, Cities and <a class="el" href="class_reservoir.html" title="Allows to represent a reservoir.">Reservoir</a> as well was all the connections between the nodes </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a03eb6dc6411a88720c3448d6b1d715f4" name="a03eb6dc6411a88720c3448d6b1d715f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03eb6dc6411a88720c3448d6b1d715f4">&#9670;&#160;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the vertex being added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30911cf23d21b266464621a233b89370" name="a30911cf23d21b266464621a233b89370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30911cf23d21b266464621a233b89370">&#9670;&#160;</a></span>augmentFlowPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::augmentFlowPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augments the flow along the augmenting path found in the residual network from the source vertex to destination vertex The flow is increased by the amount f given in the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source vertex </td></tr>
    <tr><td class="paramname">sink</td><td>Destination vertex </td></tr>
    <tr><td class="paramname">f</td><td>Amount to augment the flow along the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1721869d8c887ef0cf5342b3459a98a" name="ae1721869d8c887ef0cf5342b3459a98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1721869d8c887ef0cf5342b3459a98a">&#9670;&#160;</a></span>calculateMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmetrics.html">metrics</a> Graph::calculateMetrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the basic metrics of the network such as the average, variance and maximum difference. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a struct containing the average, variance and maximum difference </dd></dl>

</div>
</div>
<a id="a75f56175964d25bc53cfb65c80f82644" name="a75f56175964d25bc53cfb65c80f82644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f56175964d25bc53cfb65c80f82644">&#9670;&#160;</a></span>checkWaterNeeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::pair&lt; std::string, double &gt; &gt; Graph::checkWaterNeeds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to verify if all the water reservoirs supply enough water to all its delivery sites. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a set of pairs, listing all the cities that canÂ´t be supplied with the desired amount of water Each pair has a string (that holds the ID of the city) and a double value (that represents the water deficit of that city) </dd></dl>

</div>
</div>
<a id="af86360a1cb3c17ab52d915f662c2d802" name="af86360a1cb3c17ab52d915f662c2d802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86360a1cb3c17ab52d915f662c2d802">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::edmondsKarp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the Edmonds-Karp algorithm to find the maximum flow in a flow network This is done by finding augmenting paths in the residual network and augmenting the flow along the paths. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum flow in the flow network </dd></dl>

</div>
</div>
<a id="a2bb5b49c229860f491d00e3dd4a2f677" name="a2bb5b49c229860f491d00e3dd4a2f677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb5b49c229860f491d00e3dd4a2f677">&#9670;&#160;</a></span>edmondsKarpRemovePipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::edmondsKarpRemovePipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a pipeline from the flow network and then implements the Edmonds-Karp algorithm to find the maximum flow without the specified pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td><a class="el" href="class_edge.html" title="Allows to represent the information of any edge on the graph.">Edge</a> that represents the pipeline to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a340cad7c7759b5a052134e80453da6c1" name="a340cad7c7759b5a052134e80453da6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340cad7c7759b5a052134e80453da6c1">&#9670;&#160;</a></span>edmondsKarpRemovePumpingStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::edmondsKarpRemovePumpingStation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>pumpingStation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a pumping station from the flow network and then implements the Edmonds-Karp algorithm to find the maximum flow after the removal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pumpingStation</td><td><a class="el" href="class_vertex.html" title="Allows to represent the information of any vertex on the graph.">Vertex</a> that represents the pumping station to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a276893daa6d639661b2474b36808f9ce" name="a276893daa6d639661b2474b36808f9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276893daa6d639661b2474b36808f9ce">&#9670;&#160;</a></span>edmondsKarpRemoveReservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::edmondsKarpRemoveReservoir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>reservoir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a reservoir from the flow network and then implements the Edmonds-Karp algorithm to find the maximum flow without the specified reservoir After removing the reservoir, checks the effects on the water needs of the cities and prints the deficits caused by the removal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reservoir</td><td><a class="el" href="class_vertex.html" title="Allows to represent the information of any vertex on the graph.">Vertex</a> that represents the reservoir to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e031377ef9900b346f1ec9f7138f2d" name="a60e031377ef9900b346f1ec9f7138f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e031377ef9900b346f1ec9f7138f2d">&#9670;&#160;</a></span>findAllPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::findAllPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all paths from a vertex to any delivery site. </p>
<p>This method uses a DFS to find all paths from a source vertex to any delivery site that finds during the DFS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Source vertex </td></tr>
    <tr><td class="paramname">path</td><td>Vector that represents the path being analysed. </td></tr>
    <tr><td class="paramname">paths</td><td>Vector used to store all paths. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad46a70e152899f5cd6d849aae5aea76d" name="ad46a70e152899f5cd6d849aae5aea76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46a70e152899f5cd6d849aae5aea76d">&#9670;&#160;</a></span>findAugPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::findAugPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>removed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find an augmenting path in the residual graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source vertex </td></tr>
    <tr><td class="paramname">sink</td><td>Destination vertex </td></tr>
    <tr><td class="paramname">removed</td><td>In case it's different from nullptr, identifies the vertex that no longer belongs to the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an augmenting path is found, false otherwise </dd></dl>

</div>
</div>
<a id="a398749631275c96ec19e138b8a41a0fe" name="a398749631275c96ec19e138b8a41a0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398749631275c96ec19e138b8a41a0fe">&#9670;&#160;</a></span>findAugPathSubGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::findAugPathSubGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find an augmenting path in the residual subgraph from the source to the sink vertex, using BFS (breadth-first search) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source vertex of the augmenting path </td></tr>
    <tr><td class="paramname">sink</td><td>Destination vertex of the augmenting path </td></tr>
    <tr><td class="paramname">subGraph</td><td>Subgraph in which the augmenting path is searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an augmenting path is found, false otherwise </dd></dl>

</div>
</div>
<a id="a01046a11706fbfcea0c467bdaeadb0d5" name="a01046a11706fbfcea0c467bdaeadb0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01046a11706fbfcea0c467bdaeadb0d5">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to find a vertex on the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Identifies the code of the vertex being looked for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the vertex being looked for or nullptr otherwise </dd></dl>

</div>
</div>
<a id="afd115f2a5335b5a426c491416d9f59fd" name="afd115f2a5335b5a426c491416d9f59fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd115f2a5335b5a426c491416d9f59fd">&#9670;&#160;</a></span>getCity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_city.html">City</a> * Graph::getCity </td>
          <td>(</td>
          <td class="paramtype">cityEnum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a city in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Enum used to identify if the id, code or name will be used in the search </td></tr>
    <tr><td class="paramname">str</td><td>String that holds the name or code of the city </td></tr>
    <tr><td class="paramname">id</td><td>Holds the id of the city </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the city if it was found or nullptr otherwise </dd></dl>

</div>
</div>
<a id="acb92fa5002413372c5fb841cf6c800f8" name="acb92fa5002413372c5fb841cf6c800f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb92fa5002413372c5fb841cf6c800f8">&#9670;&#160;</a></span>getReservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_reservoir.html">Reservoir</a> * Graph::getReservoir </td>
          <td>(</td>
          <td class="paramtype">reservoirEnum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a reservoir in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Enum used to identify if the id, code or name will be used in the search </td></tr>
    <tr><td class="paramname">str</td><td>String that holds the name or code of the reservoir </td></tr>
    <tr><td class="paramname">id</td><td>Holds the id of the reservoir </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the reservoir if it was found or nullptr otherwise </dd></dl>

</div>
</div>
<a id="a3b1339be85fed6670fa20570ade04b8d" name="a3b1339be85fed6670fa20570ade04b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1339be85fed6670fa20570ade04b8d">&#9670;&#160;</a></span>getStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_station.html">Station</a> * Graph::getStation </td>
          <td>(</td>
          <td class="paramtype">stationEnum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a city in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Enum used to identify if the id or code will be used in the search </td></tr>
    <tr><td class="paramname">str</td><td>String that holds the code of the station </td></tr>
    <tr><td class="paramname">id</td><td>Holds the id of the station </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the station if it was found or nullptr otherwise </dd></dl>

</div>
</div>
<a id="a81b303fc43e1282bf965758aa6777269" name="a81b303fc43e1282bf965758aa6777269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b303fc43e1282bf965758aa6777269">&#9670;&#160;</a></span>incomeEdgesFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::incomeEdgesFull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>allPaths</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if the income edges of the subgraph are full or close to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allPaths</td><td>Represents the sub-graph being analysed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all income edges are full or close to be or False if at least one is not full. </dd></dl>

</div>
</div>
<a id="ac38f1c9d15d4c20de90a78700da74a35" name="ac38f1c9d15d4c20de90a78700da74a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38f1c9d15d4c20de90a78700da74a35">&#9670;&#160;</a></span>minResAugPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::minResAugPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find a minimal augmenting path in the residual graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source vertex </td></tr>
    <tr><td class="paramname">sink</td><td>Destination vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum flow that can be sent from the source vertex to the destination vertex through the path found If no path is found, returns 0 </dd></dl>

</div>
</div>
<a id="a9c7c1fa61faa4e740c2375799a78c84b" name="a9c7c1fa61faa4e740c2375799a78c84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7c1fa61faa4e740c2375799a78c84b">&#9670;&#160;</a></span>removePumpingStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removePumpingStation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>pumpingStation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to see if by temporarily removing a pumping station affects the delivery capacity to all the cities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pumpingStation</td><td><a class="el" href="class_vertex.html" title="Allows to represent the information of any vertex on the graph.">Vertex</a> that represents the pumping station to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a445ee06622688209e83d60fc96dffb58" name="a445ee06622688209e83d60fc96dffb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445ee06622688209e83d60fc96dffb58">&#9670;&#160;</a></span>removeReservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeReservoir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>reservoir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to see how the delivery sites are affected when a reservoir is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reservoir</td><td><a class="el" href="class_vertex.html" title="Allows to represent the information of any vertex on the graph.">Vertex</a> that represents the reservoir to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9bf892a442aa0f2922c36d861951cb6" name="aa9bf892a442aa0f2922c36d861951cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bf892a442aa0f2922c36d861951cb6">&#9670;&#160;</a></span>removeVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the vertex all all the connection it belonged to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="class_vertex.html" title="Allows to represent the information of any vertex on the graph.">Vertex</a> being removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>header/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
